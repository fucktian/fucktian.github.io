<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>R3与R0通信</title>
      <link href="/2024/06/08/R3%E4%B8%8ER0%E9%80%9A%E4%BF%A1/"/>
      <url>/2024/06/08/R3%E4%B8%8ER0%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="07-R3与R0通信"><a href="#07-R3与R0通信" class="headerlink" title="07 R3与R0通信"></a>07 R3与R0通信</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>保护模式：保护的主要是硬件</p><p>最简单的保护手段就是分给权限</p><p>R3 &#x3D;&#x3D;&#x3D;&#x3D;》不可以访问硬件</p><p>R0 &#x3D;&#x3D;&#x3D;&#x3D;》可以访问硬件</p><p>操作系统致命的问题：不开发硬件，却支持各个厂家的硬件</p><p>厂家 写出的代码 必须能访问到硬件(R0)</p><p>必须要同一接口， <strong>SYS驱动文件</strong></p><p>操作系统一启动 把所有sys文件加载上来</p><p>硬件驱动 其实就是一个服务程序 </p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;专门服务硬件</p><p>操作系统给硬件厂家的开发框架</p><p>操作系统必须要支持所有硬件的操作 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;设备概念</p><p>设备对象DEVICE_OBJECT</p><p>框架需要抽象出他们的统一操作</p><p>I&#x2F;O &#x3D;&#x3D;&#x3D;读写</p><p>IO管理器 一切都是文件</p><p>文件先和设备绑定起来</p><p>R3操作文件 等于操作设备对象</p><p>R3操作API时就会向IO管理器发送IRP请求 比如创建文件就会发送创建IRP请求</p><p>IRP消息只能设备去接收 创建设备时需要提供回调函数  </p><p>当注册回调函数时， IO管理器就可通过IRP消息找到回调函数</p><p>IoCreateDevice(pDriverObject)</p><p>首先创建设备对象</p><p><img src="/.com//image-20240408225430336.png" alt="image-20240408225430336"></p><p>还需设置R3和R0通信方式</p><p>缓冲类型设置</p><p><img src="/.com//image-20240409102455010.png" alt="image-20240409102455010"></p><p>可以理解为R3发送过来的数据，OS将数据拷贝到内核地址，内核去读写</p><p>直接读写方式 R3 R0 指向同一物理页</p><p>其他读写 R0 直接读R3内存(不安全的)</p><p>创建符号链接才能被R3找到(比如C盘路径就是符号链接)</p><p>通过设备去创建符号链接</p><p><img src="/.com//image-20240409102926195.png" alt="image-20240409102926195"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建符号链接后，系统和应用程序可以通过这个链接来访问设备。具体来说，会有以下几个方面的影响：</span><br><span class="line"></span><br><span class="line">1. 提高访问效率：通过符号链接，用户模式的应用程序可以方便地访问到内核模式下的设备。因为设备名只能被内核模式下的其他驱动所识别，而符号链接可以被用户模式下的应用程序识别。</span><br><span class="line">2. 提供访问路径：在应用程序中，可以通过符号链接名来访问设备。例如，C盘就是一个符号链接名，它在用户模式下表示为&quot;\\.\C:&quot;，在内核模式下表示为&quot;\??C:&quot;。</span><br><span class="line">3. 实现设备管理：符号链接还可以用于设备的管理和控制。例如，通过IOCTL（I/O控制代码）定义，可以实现对设备的复制、移动等操作。</span><br><span class="line">4. 支持即插即用：符号链接还与即插即用设备 ID、硬件 ID和兼容 ID相关联，这些ID有助于系统的设备管理和驱动程序的安装。</span><br><span class="line">5. 增强系统稳定性：符号链接的使用有助于保持系统的稳定性，因为它允许系统在不改变底层设备对象的情况下，通过符号链接来适应设备的动态变化。</span><br><span class="line">6. 方便调试和维护：对于开发人员来说，符号链接使得在开发和调试过程中更容易定位和访问特定的设备对象。</span><br><span class="line"></span><br><span class="line">总之，创建符号链接是驱动开发中的一个关键步骤，它不仅提供了一种机制来简化应用程序与设备之间的通信，还有助于设备的管理和系统的稳定运行。</span><br></pre></td></tr></table></figure><p>操作系统内核提供了很多操作接口，我们只需注册即可</p><p>设备对象中有一个数组就是回调函数</p><p><img src="/.com//image-20240409103716177.png" alt="image-20240409103716177"></p><p>注册</p><p>每个项都初始化默认回调函数</p><p><img src="/.com//image-20240409103945761.png" alt="image-20240409103945761"></p><p>然后在后面进行具体操作修改</p><p><img src="/.com//image-20240409104137491.png" alt="image-20240409104137491">  </p><p><img src="/.com//image-20240409105608892.png" alt="image-20240409105608892"></p><p>  <strong>return STATUS_SUCCESS;</strong></p><p>返回结果，但不代表操作完成                 </p><p><em>假设读取文件时，读取1000个字节，使用的是异步IO(函数不堵塞,立即返回)。操作是成功了，但是不一定读取完成</em></p><p>irp中io状态才代表irp操作完成</p><p>实际读取的字节数 </p><p>Irp-&gt;IpStatus.Information &#x3D; 0;</p><p>有些API比如说会导致阻塞的API,如果IRP没有结束，线程是挂起的</p><p>IO_NO_INCREMENT表示线程恢复，正常执行</p><p><img src="/.com//image-20240409112920974.png" alt="image-20240409112920974"></p><h3 id="PIO-STACK-LOCATION分层驱动"><a href="#PIO-STACK-LOCATION分层驱动" class="headerlink" title="PIO_STACK_LOCATION分层驱动"></a><strong>PIO_STACK_LOCATION</strong>分层驱动</h3><p>在Windows提供给硬件的驱动框架中 从R3发送IRP请求到.SYS文件</p><p><img src="/.com//image-20240409113505728.png" alt="image-20240409113505728"></p><p>向下传递，类似于函数调用，间接性成了堆栈</p><p>但是有些参数是共用的，所以有IRP头</p><p><img src="/.com//image-20240409113723113.png" alt="image-20240409113723113"></p><p>分层驱动概念</p><p>IoCallDriver() 调用下一层驱动，向下传递IRP</p><p>拿到R3缓冲区，在IRP头里(共用的)</p><p>概念 重叠IO模型 异步</p><p>写操作</p><p><img src="/.com//image-20240409143444990.png" alt="image-20240409143444990"></p><h3 id="控制码"><a href="#控制码" class="headerlink" title="控制码"></a>控制码</h3><p><img src="/.com//image-20240409144048969.png" alt="image-20240409144048969"></p><p>就可以通过控制码写一些switchcase</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_IOCTRL_BASE 0x8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRP_IOCTRL_CODE(i) CTL_CODE(FILE_DEVICE_UNKNOWN,IRP_IOCTRL_BASE + i,METHOD_BUFFERED,FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_PROCESS IRP_IOCTRL_CODE(0)</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (1) </span><br><span class="line">&#123;</span><br><span class="line">    char ReadBuf[1024] = &#123; 0 &#125;;</span><br><span class="line">    char WriteBuf[1024] = &#123; 0 &#125;;</span><br><span class="line">    DWORD dwRet = 0;</span><br><span class="line">    printf(&quot;输入字符串\r\n&quot;);</span><br><span class="line">    scanf(&quot;%s&quot;,&amp;ReadBuf);</span><br><span class="line">    DeviceIoControl(hFile, GET_PROCESS, ReadBuf,sizeof(ReadBuf), WriteBuf,sizeof(WriteBuf),&amp;dwRet,0);</span><br><span class="line">    printf(&quot;%d %s\r\n&quot;, dwRet, WriteBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ReadBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">char</span> WriteBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入字符串\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;ReadBuf);</span><br><span class="line">    <span class="built_in">DeviceIoControl</span>(hFile, GET_PROCESS, ReadBuf,<span class="built_in">sizeof</span>(ReadBuf), WriteBuf,<span class="built_in">sizeof</span>(WriteBuf),&amp;dwRet,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s\r\n&quot;</span>, dwRet, WriteBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
